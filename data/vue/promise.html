<b>Первое</b>: промисы нужны тогда, когда есть асинхронный процесс, который неизвестно когда завершится, 
и неизвестно чем завершится<br/>
<b>Второе</b>: промис создается с помощью конструктора Promise:<br/>
<pre class="code-snippet">
  var thePromise = new Promise (...)
</pre><br/>
<b>Третье</b>: в качестве параметра промису всегда передается функция<br/>
<pre class="code-snippet">
  var thePromise = new Promise ( function ... )
</pre><br/>
Эта функция содержит код какой-то асинхронной операции<br/>
Например, ввода данных (кто может предсказать, сколько времени понадобится юзеру, чтобы ввести слово из трех букв?)...<br/>
Получения данных от сервера...<br/>
Загрузки изображений...<br/>
...в общем, любой операции неизвестной продолжительности с непредсказуемым результатом<br/>
Точнее, когда результат операции характеризуется булевым значением: либо получилось то, либо нет<br/>
(что мы там получили - молоко или пирожок с капустой - это уже дело десятое, главное - получили или нет) <br/>
Таким образом, эта функция, которую мы передаем конструктору Promise, сама не уверена, что у нее получится то, что она 
должна сделать, и сколько ей придется ждать ответа, будь то отрицательный или положительный ответ)<br/>
Она стратует операцию, и на этом ее миссия заканчивается<br/>
Далее вступают новые игроки, каждый - на своей половине поля<br/>
Конечно, раз игроки - значит, функции<br/>
Действующие, так сказать, персонажи<br/>
Один из этих игроков (по старинке - колбэков) вступает в игру в случае провала операции<br/>
Второй игрок разыгрывает успешный финал<br/>
Итак,<br/>
<b>Четвертое</b>: наша функция-стартер асинхронной операции имеет два параметра<br/>
Это наши игроки, которые вступят в игру только при условии, что выпал их жребий<br/>
Что они будут делать - нашу функцию не интересует<br/>
Кто они такие и как их зовут - ей тоже безразлично<br/>
Она просто передаст им их полномочия<br/>

<b>Пятое</b>: Мы создали промис<br/>
<pre class="code-snippet">
var thePromise = new Promise (
    function ( resolve, reject ) {
       ... resolve ( response )
       ... reject ( error )
    }
)
</pre><br/>
где resolve - игрок, вступающий в случае успешного завершения операции<br/>
а reject - игрок на случай провала<br/>

осталось только созданный промис запустить в работу:<br/>
<pre class="code-snippet">
thePromise
  .then ( response => {
       ...
  })
  .catch ( error => {
       ... 
})
</pre><br/>
Где тут игрок resolve? - конечно, в поле then, ведь он идет первым в списке параметров функции <br/>
в поле catch будет играть reject<br/>
т.е. формальные имена игроков resolve и reject наполняются конкретикой (кодом)<br/>
resolve будет заменен на response => { ... }<br/>
а вместо reject будет error => { ... }<br/>

<small>Примечание: resolve и reject - имена вымышленные, вы можете дать игрокам свои собственные имена<br/>
аналогично response и error - это параметры, которые передаются колбэкам, и называть их можно по своему усмотрению<br/></small>
