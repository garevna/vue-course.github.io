<b>Первое</b>: промисы нужны тогда, когда есть асинхронный процесс, который неизвестно когда завершится,
и неизвестно чем завершится<br/>
<b>Второе</b>: промис создается с помощью конструктора <spec_words>Promise</spec_words>:<br/>
<pre class="code-snippet">
  var thePromise = new Promise (...)
</pre><br/>
<b>Третье</b>: в качестве параметра промису всегда передается функция<br/>
<pre class="code-snippet">
  var thePromise = new Promise ( function ... )
</pre><br/>
Эта функция содержит код какой-то асинхронной операции<br/>
Например, ввода данных (кто может предсказать, сколько времени понадобится юзеру, чтобы ввести слово из трех букв?)...<br/>
Получения данных от сервера...<br/>
Загрузки изображений...<br/>
...в общем, любой операции неизвестной продолжительности с непредсказуемым результатом<br/>
Точнее, когда результат операции характеризуется булевым значением: либо получилось то, либо нет<br/>
(что мы там получили - молоко или пирожок с капустой - это уже дело десятое, главное - получили или нет) <br/>
Таким образом, эта функция, которую мы передаем конструктору <spec_words>Promise</spec_words>, сама не уверена, что у нее получится то, что она 
должна сделать, и сколько ей придется ждать ответа, будь то отрицательный или положительный ответ)<br/>
Она стратует операцию, и на этом ее миссия заканчивается<br/>
Далее вступают новые игроки, каждый - на своей половине поля<br/>
Конечно, раз игроки - значит, функции<br/>
Действующие, так сказать, персонажи<br/>
Один из этих игроков (по старинке - колбэков) вступает в игру в случае провала операции<br/>
Второй игрок разыгрывает успешный финал<br/>
Итак,<br/>
<b>Четвертое</b>: наша функция-стартер асинхронной операции имеет два параметра<br/>
Это наши игроки, которые вступят в игру только при условии, что выпал их жребий<br/>
Что они будут делать - нашу функцию не интересует<br/>
Кто они такие и как их зовут - ей тоже безразлично<br/>
Она просто передаст им их полномочия<br/>

<b>Пятое</b>: Мы создали промис<br/>
<pre class="code-snippet">
var thePromise = new Promise (
    function ( resolve, reject ) {
       ... resolve ( response )
       ... reject ( error )
    }
)
</pre><br/>
где <var_names>resolve</var_names> - игрок, вступающий в случае успешного завершения операции<br/>
а <var_names>reject</var_names> - игрок на случай провала<br/>

осталось только созданный промис запустить в работу:<br/>
<pre class="code-snippet">
thePromise
  .then ( response => {
       ...
  })
  .catch ( error => {
       ...
})
</pre><br/>
Где тут игрок <var_names>resolve</var_names>? - конечно, в поле then, ведь он идет первым в списке параметров функции <br/>
в поле <spec_words>catch</spec_words> будет играть <var_names>reject</var_names><br/>
т.е. формальные имена игроков <var_names>resolve</var_names> и <var_names>reject</var_names> наполняются конкретикой (кодом)<br/>
<var_names>resolve</var_names> будет заменен на <var_names>response</var_names> => { ... }<br/>
а вместо <var_names>reject</var_names> будет <var_names>error</var_names> => { ... }<br/>

<small>Примечание: <var_names>resolve</var_names> и <var_names>reject</var_names> - имена вымышленные,
  вы можете дать игрокам свои собственные имена<br/>
аналогично <var_names>response</var_names> и <var_names>error</var_names> - это параметры, которые передаются колбэкам, и называть их можно по своему усмотрению<br/></small>
